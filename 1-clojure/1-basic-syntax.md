# Базовый синтаксис

Вы можете воспользоваться сервисами repl.it и clojurescript.io,
чтобы поэкспериментировать с языком прямо в браузере без установки оркужения на свой компьютер.

Цель этих примеров - научиться читать, но не писать код на clojure.

```clojure
;; комментарий

;; печать на экран
;; prn - функция печати на экран
;; "hellow world" - строка, аргумент функции
(prn "hello world")

;; Используется только префиксная(польская нотация),
;; т.е. функция стоит всегда на первом месте, а за ней ее агрументы.
;; Вместо функции может быть специальная форма или макрос, но не будем касаться этой темы.
;; Т.е. на первом месте внутри скобок находится нечто, что будет вызвано.
;; x.method(y, z) -> (method x y z)
;; func(x, y, z) -> (func x y z)
;; x operator y -> (operator x y)

;; Clojure - язык не ленивый, и для функций сначала вычисляются аргументы
;; str - функция конкатенации строк
(prn (str "hello" " " "world"))
;; (prn "hello world") ;; подставляем вычисленный аргумент

;; Для демонстации языка воспользуемя утверждениями(assert).
;; Если агрумент ложный, то будет брошено исключение,
;; если истинный, то просто вернется nil.
(assert true) ;; #=> nil
;; (assert false) ;; AssertionError Assert failed: false
;; (assert nil)   ;; AssertionError Assert failed: nil

;; Например, я утверждаю, что 1 = 1
(assert (= 1 1))

;; привычные операторы могут принимать переменное количество аргуметов
(assert (= 1)) ;; всегда истинно для одного аргумента
(assert (= 1 1 1)) ;; 1 = 1 = 1

(assert (< 1)) ;; всегда истинно для одного аргумента
(assert (< 1 2 3)) ;; 1 < 2 < 3

;; примитивные типы - java типы
;; class - функция, возвращающая класс своего аргумента
(assert (= java.lang.String  (class "some string")))
(assert (= java.lang.Long    (class 1)))
(assert (= java.lang.Boolean (class true)))

;; мы можем задать название некоторому значению
;; let - специальная форма, позволяющая давать локальные названия
(let [x 1]
  (assert (= 1 x)))
;; вне let x не существует, т.е. это локальная видимость

;; новое значение можно связвть с тем же названием
(let [x 1
      x 2]
  (assert (= 2 x)))

;; или переопределить внешнее
(let [+ -]
  (assert (= 0 (+ 1 1))))

;; в рамках текущего пространства имен можно объявить глобальное значение
(def x 1)
(assert (= 1 x))

;; определение анонимной функции
;; x - аргумент
;; (+ 1 x) - тело функции
(let [f (fn [x] (+ 1 x))]
  (assert (= 3 (f 2))))

;; вместо (def f (fn [x] (+ 1 x)))
(defn f [x] (+ 1 x))
(assert (= 3 (f 2)))

;; замыкания
(let [x 1
      f (fn [y] (+ x y))]
  (assert (= 3 (f 2))))

;; функции как значения
;; `+` - функция
(assert (= 6 (reduce + [0 1 2 3])))

;; краткая запись функции одного аргумента
(let [x [0 1 2]
      x'  (map #(+ 2 %) x)
      x'' (map (fn [i] (+ 2 i)) x)]
  (assert (= x' x'')))

;; в отличие от императивных языков, в clojure нет присваивания
;; т.е. let создвает не переменные, а только именует значения
;; если бы это было присваивание, то функция f вернула бы 2
(let [x 1
      f (fn [] x) ;; замыкание(closure)
      x 2]
  (assert (= 2 x))
  (assert (= 1 (f))))

;; Имена могут содержать некоторые спецсимволы и их комбинации.
(let [x 1
      x' x
      x? x
      ?x x
      x! x
      !x x
      +x+ x
      -x- x
      *x* x
      =x= x]
  (assert (= x x' x? ?x x! !x +x+ -x- *x* =x=)))

;; vector
;; хранит произвольные типы
;; доступ по индексу
(let [x [0 "str" true [1 2 3]]]
  (assert (= "str" (get x 1)))
  (assert (= 0 (first x)))
  (assert (= "str" (second x))))

;; map
;; ключи и значения - любые типы
;; запятая в clojure - просто пробельный символ, который можно опускать,
;; и используется для улучшения читаемости кода
(let [x {:key 1, "key" 2, 2 3, true "4", [1 2] "5", nil 6}]
  (assert (= 1 (get x :key)))
  (assert (= 6 (get x nil))))

;; keyword
;; Представляют сами себя. Аналог символов в ruby или атомов в erlang.
;; Используются как ключи в ассоциативных массивах.
;; Реализуют интефейс функций, т.е. принимает map и возвращает ассоциированное с собой значение
(let [x {:key "value"}]
  (assert (= "value" (:key x))))

;; Все clojure значения - неизменяемые.
;; При изменении возвращается новый объект, старый остается доступен.
;; При этом не происходит полного копирования,
;; т.е. новая структура переиспользует старую.
(let [x  [0 1 2 3]
      x' (pop x)]
  (assert (= [0 1 2 3] x))
  (assert (= [0 1 2] x')))

;; assoc - добавляет ключи и значения
(let [x {}
      x' (assoc x :k1 1 :k2 2)]
  (assert (= {} x))
  (assert (= {:k1 1, :k2 2} x')))
```

Этот код можно выполнить [прямо в браузере](https://repl.it/@darkleaf/clojure-tour).
Там доступна консоль, в которой можно выполнять произвольные clojure выражения.
